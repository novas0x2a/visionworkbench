// __BEGIN_LICENSE__
// Copyright (C) 2006-2010 United States Government as represented by
// the Administrator of the National Aeronautics and Space Administration.
// All Rights Reserved.
// __END_LICENSE__


// TestPinholeModel.h
#include <cxxtest/TestSuite.h>

#include <boost/random.hpp>

#include <vw/Math/Vector.h>
#include <vw/Math/EulerAngles.h>
#include <vw/Math/LinearAlgebra.h>

#include <vw/FileIO.h>

#include <vw/Camera/PinholeModel.h>
#include <vw/Camera/CameraTransform.h>
#include <vw/Camera/CameraGeometry.h>

using namespace vw;
using namespace vw::camera;

class TestPinholeModel : public CxxTest::TestSuite
{
public:

  void test_basic_pinhole_model()
  {
    Matrix<double,3,3> pose;
    pose.set_identity();

    // Create an imaginary 1000x1000 pixel imager
    PinholeModel pinhole( Vector3(0,0,0), // camera center
                          pose,           // camera pose
                          500,500,        // fx, fy
                          500,500,        // cx, cy
                          NullLensDistortion());

    // TS_TRACE(stringify(pinhole));
    TS_ASSERT_EQUALS(pinhole.point_to_pixel(Vector3(0,0,10)),Vector2(500,500));
    TS_ASSERT_EQUALS(pinhole.point_to_pixel(Vector3(-10,0,10)),Vector2(0,500));
    TS_ASSERT_EQUALS(pinhole.point_to_pixel(Vector3(10,0,10)),Vector2(1000,500));
    TS_ASSERT_EQUALS(pinhole.point_to_pixel(Vector3(0,-10,10)),Vector2(500,1000));
    TS_ASSERT_EQUALS(pinhole.point_to_pixel(Vector3(0,10,10)),Vector2(500,0));

  }


  void test_coordinate_frames()
  {
    Matrix<double,3,3> pose;
    pose.set_identity();

    // Create an imaginary 1000x1000 pixel imager, where the camera
    // coordinate system is mapped as follows:
    //
    // +u : along the camera +Y axis
    // +v : along the camera +X axis
    // +w : along the camera -Z axis
    PinholeModel pinhole( Vector3(0,0,0), // camera center
                          pose,           // camera pose
                          500,500,        // fx, fy
                          500,500,
                          Vector3(0, 1, 0),
                          Vector3(1, 0, 0),
                          Vector3(0, 0, -1),

                          NullLensDistortion());       // cx, cy

    // TS_TRACE(stringify(pinhole));
    TS_ASSERT_EQUALS(pinhole.point_to_pixel(Vector3(0,0,-10)),Vector2(500,500));
    TS_ASSERT_EQUALS(pinhole.point_to_pixel(Vector3(-10,0,-10)),Vector2(500,0));
    TS_ASSERT_EQUALS(pinhole.point_to_pixel(Vector3(10,0,-10)),Vector2(500,1000));
    TS_ASSERT_EQUALS(pinhole.point_to_pixel(Vector3(0,-10,-10)),Vector2(0,500));
    TS_ASSERT_EQUALS(pinhole.point_to_pixel(Vector3(0,10,-10)),Vector2(1000,500));

    TS_TRACE(stringify(pinhole.point_to_pixel(Vector3(-10,0,-10))));
    TS_TRACE(stringify(pinhole.point_to_pixel(Vector3(10,0,-10))));
    TS_TRACE(stringify(pinhole.point_to_pixel(Vector3(0,-10,-10))));
    TS_TRACE(stringify(pinhole.point_to_pixel(Vector3(0,10,-10))));
  }

  void test_pixel_to_vector()
  {
    Matrix<double,3,3> pose;
    pose.set_identity();

    // Create an imaginary 1000x1000 pixel imager
    PinholeModel pinhole( Vector3(0,0,0), // camera center
                          pose,           // camera pose
                          500,500,        // fx, fy
                          500,500,
                          NullLensDistortion());       // cx, cy


    PinholeModel pinhole2( Vector3(10,10,10), // camera center
                          pose,           // camera pose
                          500,500,        // fx, fy
                          500,500,
                          NullLensDistortion());       // cx, cy

    Matrix<double,3,3> rot = vw::math::euler_to_quaternion(1.15, 0.0, -1.57, "xyz").rotation_matrix();
    PinholeModel pinhole3(Vector3(-0.329, 0.065, -0.82),
                         rot,
                         605.320556640625,
                         606.3638305664062,
                         518.89208984375,
                         387.5555114746094);

    PinholeModel pinhole4(Vector3(-0.329, 0.065, -0.82),
                          rot,
                          605.320556640625,
                          606.3638305664062,
                          518.89208984375,
                          387.5555114746094,
                          TsaiLensDistortion(Vector4(-0.2796604335308075,
                                                     0.1031486615538597,
                                                     -0.0007824968779459596,
                                                     0.0009675505571067333)));

    Vector2 result1 = pinhole.point_to_pixel(pinhole.pixel_to_vector(Vector2(0,0))+pinhole.camera_center(Vector2(0,0)));
    Vector2 result2 = pinhole2.point_to_pixel(pinhole2.pixel_to_vector(Vector2(0,0))+pinhole2.camera_center(Vector2(0,0)));
    Vector2 result3 = pinhole3.point_to_pixel(pinhole3.pixel_to_vector(Vector2(0,0))+pinhole3.camera_center(Vector2(0,0)));
#if defined(VW_HAVE_PKG_LAPACK) && VW_HAVE_PKG_LAPACK==1
    Vector2 result4 = pinhole4.point_to_pixel(pinhole4.pixel_to_vector(Vector2(0,0))+pinhole4.camera_center(Vector2(0,0)));
#endif
    TS_ASSERT_DELTA(result1(0), 0, 1e-8);
    TS_ASSERT_DELTA(result1(1), 0, 1e-8);
    TS_ASSERT_DELTA(result2(0), 0, 1e-8);
    TS_ASSERT_DELTA(result2(1), 0, 1e-8);
    TS_ASSERT_DELTA(result3[0], 0, 1e-8);
    TS_ASSERT_DELTA(result3[1], 0, 1e-8);
#if defined(VW_HAVE_PKG_LAPACK) && VW_HAVE_PKG_LAPACK==1
    TS_ASSERT_DELTA(result4(0), 0, 1e-3);
    TS_ASSERT_DELTA(result4(1), 0, 1e-3);
#endif
  }

  void test_tsai_distortion()
  {
    // Create an imaginary 1000x1000 pixel imager
    PinholeModel pinhole( Vector3(0,0,0),                 // camera center
                          math::identity_matrix<3>(),     // camera pose
                          500,500,                        // fx, fy
                          500,500,                        // cx, cy
                          TsaiLensDistortion(Vector4(-0.2805362343788147,
                                                     0.1062035113573074,
                                                     -0.0001422458299202845,
                                                     0.00116333004552871)));
    const LensDistortion* distortion = pinhole.lens_distortion();

#if defined(VW_HAVE_PKG_LAPACK) && VW_HAVE_PKG_LAPACK==1
    Vector2 distorted_pix = distortion->distorted_coordinates(pinhole, Vector2(200,200));
    Vector2 undistorted_pix = distortion->undistorted_coordinates(pinhole, distorted_pix);

    TS_ASSERT_DELTA(distorted_pix[0], 244.865, 0.1);
    TS_ASSERT_DELTA(distorted_pix[1], 244.395, 0.1);
    TS_ASSERT_DELTA(undistorted_pix[0], 200, 0.1);
    TS_ASSERT_DELTA(undistorted_pix[1], 200, 0.1);
#endif
  }

  void test_scale_pinhole()
  {
    Matrix<double,3,3> rot = vw::math::euler_to_quaternion(1.15, 0.0, -1.57, "xyz").rotation_matrix();
    PinholeModel pinhole4(Vector3(-0.329, 0.065, -0.82),
                          rot,
                          605.320556640625,
                          606.3638305664062,
                          518.89208984375,
                          387.5555114746094,
                          TsaiLensDistortion(Vector4(-0.2796604335308075,
                                                     0.1031486615538597,
                                                     -0.0007824968779459596,
                                                     0.0009675505571067333)));
    PinholeModel scaled = scale_camera(pinhole4, .1);

    Vector3 point = Vector3(2,-1,1) +5*pinhole4.pixel_to_vector(Vector2(500,500))+pinhole4.camera_center();

    Vector2 o_return = pinhole4.point_to_pixel(point);
    Vector2 s_return = scaled.point_to_pixel(point);

    TS_ASSERT_DELTA(o_return[0],s_return[0]*10,5); // Lens distortion doesn't
    TS_ASSERT_DELTA(o_return[1],s_return[1]*10,5); // seem to be too accurate
  }

  void test_pinhole_set_camera_matrix () {
    // First set control camera
    Matrix<double,3,3> pose = math::euler_to_rotation_matrix(1.3,2.0,-.7,"xyz");

    // Create an imaginary 1000x1000 pixel imager
    PinholeModel control_pinhole( Vector3(0,4,-10),
                                  pose, 600, 700,
                                  500, 500,
                                  NullLensDistortion() );

    // Make solve control camera (w/ random input for now)
    pose.set_identity();
    PinholeModel solved_pinhole( Vector3(-5,-2,5),
                                 pose, 833, 544,
                                 400, 700,
                                 NullLensDistortion() );

    // Create Measurements used to solve for camera matrix
    std::vector<Vector<double> > world_m, image_m;
    boost::minstd_rand random_gen(42u);
    random_gen.seed((unsigned int)(::time(0)));
    boost::normal_distribution<double> normal(0,20);
    boost::variate_generator<boost::minstd_rand, boost::normal_distribution<double> > generator( random_gen, normal );
    for ( uint8 i = 0; i < 6; i++ ) {
      Vector3 point( generator(), generator(), generator()+60.0 );
      world_m.push_back( Vector4(point[0],point[1],point[2],1) );
      Vector2 pixel = control_pinhole.point_to_pixel(point);
      image_m.push_back( Vector3(pixel[0],pixel[1],1) );
    }

    // Building Camera Matrix
    CameraMatrixFittingFunctor fitfunc;
    Matrix<double> P = fitfunc(world_m,image_m);

    solved_pinhole.set_camera_matrix( P );

    // Compare camera matrices
    {
      Vector3 solved = solved_pinhole.camera_center( Vector2() );
      Vector3 control = control_pinhole.camera_center( Vector2() );
      for ( uint8 i = 0; i < 3; i++ )
        TS_ASSERT_DELTA( solved[i], control[i], 1e-8 );
    }
    {
      Quaternion<double> solved = solved_pinhole.camera_pose( Vector2() );
      Quaternion<double> control = control_pinhole.camera_pose( Vector2() );
      for ( uint8 i = 0; i < 4; i++ )
        TS_ASSERT_DELTA( solved[i], control[i], 1e-8 );
    }
    {
      double s_fu, s_fv, s_cu, s_cv;
      double c_fu, c_fv, c_cu, c_cv;
      solved_pinhole.intrinsic_parameters( s_fu, s_fv, s_cu, s_cv );
      control_pinhole.intrinsic_parameters( c_fu, c_fv, c_cu, c_cv );
      TS_ASSERT_DELTA( s_fv/s_fu, c_fv/c_fu, 1e-2 ); // Only accurate to 1%
      TS_ASSERT_DELTA( s_cu/s_fu, c_cu/c_fu, 1e-2 );
      TS_ASSERT_DELTA( s_cv/s_fu, c_cv/c_fu, 1e-2 );
    }
  }

};
