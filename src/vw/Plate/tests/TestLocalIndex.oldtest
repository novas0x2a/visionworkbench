// __BEGIN_LICENSE__
// Copyright (C) 2006-2010 United States Government as represented by
// the Administrator of the National Aeronautics and Space Administration.
// All Rights Reserved.
// __END_LICENSE__


#include <cxxtest/TestSuite.h>

#include <vw/Plate/LocalIndex.h>
#include <vw/Plate/Exception.h>
#include <vw/Plate/Blob.h>
using namespace std;
using namespace vw;
using namespace vw::platefile;

#include <boost/filesystem/path.hpp>
#include <boost/filesystem/convenience.hpp>
namespace fs = boost::filesystem;


class TestLocalIndex : public CxxTest::TestSuite {
  boost::shared_array<uint8> m_test_data;

public:

  TestLocalIndex() {
    m_test_data = boost::shared_array<uint8>(new uint8[20]);
    for (int i = 0; i < 20; ++i) {
      m_test_data[i] = i;
    }
  }
  
  void check_data(boost::shared_array<uint8> a, boost::shared_array<uint8> b) {
    for (int i = 0; i < 20; ++i) 
      TS_ASSERT_EQUALS( a[i], b[i] );
  }

  void test_basic_access() {
    //    std::cout << "\n";
    std::vector<boost::shared_ptr<IndexLevel> > levels;
    
    for (int i = 0; i < 5; ++i) {
      //      std::cout << "Building index level " << i << "... " << std::flush;
      boost::shared_ptr<LocalPageGeneratorFactory> page_gen_factory;
      page_gen_factory.reset( new LocalPageGeneratorFactory("/tmp/foo"));
      boost::shared_ptr<IndexLevel> level( new IndexLevel(page_gen_factory, i, 256, 256, 100) );
      levels.push_back(level);
      //      std::cout << "done.\n";
    }
  }

  void test_index_record() {

    // Test serialization/deserialization
    TileHeader write_hdr;
    write_hdr.set_filetype("tiff");
    write_hdr.set_col(1);
    write_hdr.set_row(1);
    write_hdr.set_level(2);
    
    std::ofstream ostr("/tmp/foo.bar", std::ios::binary);
    write_hdr.SerializeToOstream(&ostr);
    ostr.close();

    std::ifstream istr("/tmp/foo.bar", std::ios::binary);
    TileHeader read_hdr;
    read_hdr.ParseFromIstream(&istr);
    istr.close();

    TS_ASSERT_EQUALS(write_hdr.col(), read_hdr.col());
    TS_ASSERT_EQUALS(write_hdr.row(), read_hdr.row());
    TS_ASSERT_EQUALS(write_hdr.level(), read_hdr.level());
    TS_ASSERT_EQUALS(write_hdr.filetype(), read_hdr.filetype());

    // Clean up
    unlink("/tmp/foo.bar");
  }
  
  void test_index_write_read() {
    const std::string plate_filename = "/tmp/foo.plate";
    fs::remove_all(plate_filename);

    // Write the basic data...
    IndexHeader rec;
    rec.set_tile_size(256);
    rec.set_tile_filetype("tif");
    rec.set_pixel_format(VW_PIXEL_RGB);
    rec.set_channel_type(VW_CHANNEL_UINT8);
    LocalIndex idx(plate_filename, rec);

    // And read it back in...
    LocalIndex idx2(plate_filename);
    
    TS_ASSERT_EQUALS(idx.version(), idx2.version());
    TS_ASSERT_EQUALS(idx.tile_size(), idx2.tile_size());
    TS_ASSERT_EQUALS(idx.tile_filetype(), idx2.tile_filetype());
  }

  void test_index_transactions() {
    const std::string plate_filename = "/tmp/foo.plate";
    fs::remove_all(plate_filename);

    // Write the basic data...
    IndexHeader rec;
    rec.set_tile_size(256);
    rec.set_tile_filetype("tif");
    rec.set_pixel_format(VW_PIXEL_RGB);
    rec.set_channel_type(VW_CHANNEL_UINT8);
    LocalIndex idx(plate_filename, rec);

    TS_ASSERT_EQUALS(idx.transaction_cursor(), vw::uint64());

    // Test one tranaction request
    int tx1 = idx.transaction_request("Test transaction #1", -1);
    TS_ASSERT_EQUALS(tx1, 1);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), vw::uint64());

    // And now a few more
    int tx2 = idx.transaction_request("Test transaction #2", -1);
    int tx3 = idx.transaction_request("Test transaction #3", -1);
    int tx4 = idx.transaction_request("Test transaction #4", -1);
    int tx5 = idx.transaction_request("Test transaction #5", -1);
    int tx6 = idx.transaction_request("Test transaction #6", -1);
    TS_ASSERT_EQUALS(tx2, 2);
    TS_ASSERT_EQUALS(tx3, 3);
    TS_ASSERT_EQUALS(tx4, 4);
    TS_ASSERT_EQUALS(tx5, 5);
    TS_ASSERT_EQUALS(tx6, 6);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), vw::uint64());

    // Now complet a transaction, but not the next one in the series.
    idx.transaction_complete(tx6, false);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), vw::uint64());

    // Now we complete the next one. the cursor should move forward by one.
    idx.transaction_complete(tx1, true);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 1);

    // Complete more transactions in reverse order
    idx.transaction_complete(tx3, true);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 3);
    idx.transaction_complete(tx2, true);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 3);

    // And the rest
    idx.transaction_complete(tx4, false);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 3);
    idx.transaction_complete(tx5, true);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 5);
  }
   
  void test_basic_read_write() {
    const std::string plate_filename = "/tmp/foo.plate";
    std::string blob_filename = plate_filename + "/plate_0.blob";
    fs::remove_all(plate_filename);

    TileHeader dummy_header0;
    dummy_header0.set_filetype("tif");
    dummy_header0.set_col(0);
    dummy_header0.set_row(0);
    dummy_header0.set_level(0);
    dummy_header0.set_transaction_id(1);

    // Write some data to the Index.
    IndexHeader hdr;
    hdr.set_tile_size(256);
    hdr.set_tile_filetype("tif");
    hdr.set_pixel_format(VW_PIXEL_RGB);
    hdr.set_channel_type(VW_CHANNEL_UINT8);
    LocalIndex idx(plate_filename, hdr);
    Blob blob(blob_filename);

    IndexRecord rec;
    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header0, m_test_data, 20));
    idx.write_update(dummy_header0, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    IndexRecord result = idx.read_request(0, 0, 0, 1);
    TS_ASSERT_EQUALS(result.blob_id(), rec.blob_id());
    TS_ASSERT_EQUALS(result.blob_offset(), rec.blob_offset());
  }

  void test_simple_index() {
    const std::string plate_filename = "/tmp/foo.plate";
    std::string blob_filename = plate_filename + "/plate_0.blob";
    fs::remove_all(plate_filename);

    TileHeader dummy_header0;
    dummy_header0.set_filetype("tif");
    dummy_header0.set_col(0);
    dummy_header0.set_row(0);
    dummy_header0.set_level(0);

    TileHeader dummy_header1;
    dummy_header1.set_filetype("tif");
    dummy_header1.set_col(0);
    dummy_header1.set_row(0);
    dummy_header1.set_level(1);

    TileHeader dummy_header2;
    dummy_header2.set_filetype("tif");
    dummy_header2.set_col(1);
    dummy_header2.set_row(0);
    dummy_header2.set_level(1);

    TileHeader dummy_header3;
    dummy_header3.set_filetype("tif");
    dummy_header3.set_col(0);
    dummy_header3.set_row(1);
    dummy_header3.set_level(1);

    TileHeader dummy_header4;
    dummy_header4.set_filetype("tif");
    dummy_header4.set_col(1);
    dummy_header4.set_row(1);
    dummy_header4.set_level(1);

    // Write some data to the Index.
    IndexHeader hdr;
    hdr.set_tile_size(256);
    hdr.set_tile_filetype("tif");
    hdr.set_pixel_format(VW_PIXEL_RGB);
    hdr.set_channel_type(VW_CHANNEL_UINT8);
    LocalIndex idx(plate_filename, hdr);
    Blob blob(blob_filename);

    IndexRecord rec;
    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header0, m_test_data, 20));
    idx.write_update(dummy_header0, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header1, m_test_data, 20));
    idx.write_update(dummy_header1, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header2, m_test_data, 20));
    idx.write_update(dummy_header2, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header3, m_test_data, 20));
    idx.write_update(dummy_header3, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header4, m_test_data, 20));
    idx.write_update(dummy_header4, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    // Test re-writing (i.e. changing) an entry.
    TileHeader dummy_header5;
    dummy_header5.set_filetype("tif");
    dummy_header5.set_col(1);
    dummy_header5.set_row(1);
    dummy_header5.set_level(1);

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header1, m_test_data, 20));
    idx.write_update(dummy_header1, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    IndexRecord result = idx.read_request(0, 0, 1, -1);
    TS_ASSERT_EQUALS(result.blob_id(), rec.blob_id());
    TS_ASSERT_EQUALS(result.blob_offset(), rec.blob_offset());

    // Now let's try some invalid reads/writes
    dummy_header5.set_col(10);
    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header5, m_test_data, 20));
    TS_ASSERT_THROWS(idx.write_update(dummy_header5, rec), TileNotFoundErr);
    idx.write_complete(rec.blob_id(), vw::uint64());

    dummy_header5.set_col(0);
    dummy_header5.set_row(2);
    dummy_header5.set_level(1);
    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header5, m_test_data, 20));
    TS_ASSERT_THROWS(idx.write_update(dummy_header5, rec), TileNotFoundErr);
    idx.write_complete(rec.blob_id(), vw::uint64());

    TS_ASSERT_THROWS(idx.read_request(0, 0, 2, -1), TileNotFoundErr);
  }


  void test_index_read_write() {
    const std::string plate_filename = "/tmp/foo.plate";
    std::string blob_filename = plate_filename + "/plate_0.blob";
    fs::remove_all(plate_filename);

    TileHeader dummy_header0;
    dummy_header0.set_filetype("tif");
    dummy_header0.set_col(0);
    dummy_header0.set_row(0);
    dummy_header0.set_level(0);

    TileHeader dummy_header1;
    dummy_header1.set_filetype("tif");
    dummy_header1.set_col(0);
    dummy_header1.set_row(0);
    dummy_header1.set_level(1);

    TileHeader dummy_header2;
    dummy_header2.set_filetype("tif");
    dummy_header2.set_col(1);
    dummy_header2.set_row(0);
    dummy_header2.set_level(1);

    TileHeader dummy_header3;
    dummy_header3.set_filetype("tif");
    dummy_header3.set_col(0);
    dummy_header3.set_row(1);
    dummy_header3.set_level(1);

    TileHeader dummy_header4;
    dummy_header4.set_filetype("tif");
    dummy_header4.set_col(1);
    dummy_header4.set_row(1);
    dummy_header4.set_level(1);

    // Write some data to the Index. 
    { 
      IndexHeader hdr;
      hdr.set_tile_size(256);
      hdr.set_tile_filetype("tif");
      hdr.set_pixel_format(VW_PIXEL_RGB);
      hdr.set_channel_type(VW_CHANNEL_UINT8);
      LocalIndex idx(plate_filename, hdr);
      Blob blob(blob_filename);

      IndexRecord rec;
      rec.set_blob_id( idx.write_request(1024) );
      rec.set_blob_offset(blob.write(dummy_header0, m_test_data, 20));
      idx.write_update(dummy_header0, rec);
      idx.write_complete(rec.blob_id(), vw::uint64());

      rec.set_blob_id( idx.write_request(1024) );
      rec.set_blob_offset(blob.write(dummy_header1, m_test_data, 20));
      idx.write_update(dummy_header1, rec);
      idx.write_complete(rec.blob_id(), vw::uint64());

      rec.set_blob_id( idx.write_request(1024) );
      rec.set_blob_offset(blob.write(dummy_header2, m_test_data, 20));
      idx.write_update(dummy_header2, rec);
      idx.write_complete(rec.blob_id(), vw::uint64());
          
      rec.set_blob_id( idx.write_request(1024) );
      rec.set_blob_offset(blob.write(dummy_header3, m_test_data, 20));
      idx.write_update(dummy_header3, rec);
      idx.write_complete(rec.blob_id(), vw::uint64());

      rec.set_blob_id( idx.write_request(1024) );
      rec.set_blob_offset(blob.write(dummy_header4, m_test_data, 20));
      idx.write_update(dummy_header4, rec);
      idx.write_complete(rec.blob_id(), vw::uint64());
    }

    // Now, let's save the data to disk, and then read it back.
    {
      LocalIndex idx2(plate_filename);
      Blob blob(blob_filename);

      // Read the data back from the index
      IndexRecord result = idx2.read_request(0, 0, 0, -1);
      TileHeader hdr = blob.read_header<TileHeader>(result.blob_offset());
      boost::shared_array<uint8> retrieved_data = blob.read_data(result.blob_offset());
      check_data(m_test_data, retrieved_data);
      TS_ASSERT_EQUALS(hdr.col(), dummy_header0.col());
      TS_ASSERT_EQUALS(hdr.row(), dummy_header0.row());
      TS_ASSERT_EQUALS(hdr.level(), dummy_header0.level());
      TS_ASSERT_EQUALS(hdr.filetype(), dummy_header0.filetype());

      result = idx2.read_request(0, 0, 1, -1);
      hdr = blob.read_header<TileHeader>(result.blob_offset());
      retrieved_data = blob.read_data(result.blob_offset());
      check_data(m_test_data, retrieved_data);
      TS_ASSERT_EQUALS(hdr.col(), dummy_header1.col());
      TS_ASSERT_EQUALS(hdr.row(), dummy_header1.row());
      TS_ASSERT_EQUALS(hdr.level(), dummy_header1.level());
      TS_ASSERT_EQUALS(hdr.filetype(), dummy_header1.filetype());

      result = idx2.read_request(1, 0, 1, -1);
      hdr = blob.read_header<TileHeader>(result.blob_offset());
      retrieved_data = blob.read_data(result.blob_offset());
      check_data(m_test_data, retrieved_data);
      TS_ASSERT_EQUALS(hdr.col(), dummy_header2.col());
      TS_ASSERT_EQUALS(hdr.row(), dummy_header2.row());
      TS_ASSERT_EQUALS(hdr.level(), dummy_header2.level());
      TS_ASSERT_EQUALS(hdr.filetype(), dummy_header2.filetype());

      result = idx2.read_request(0, 1, 1, -1);
      hdr = blob.read_header<TileHeader>(result.blob_offset());
      retrieved_data = blob.read_data(result.blob_offset());
      check_data(m_test_data, retrieved_data);
      TS_ASSERT_EQUALS(hdr.col(), dummy_header3.col());
      TS_ASSERT_EQUALS(hdr.row(), dummy_header3.row());
      TS_ASSERT_EQUALS(hdr.level(), dummy_header3.level());
      TS_ASSERT_EQUALS(hdr.filetype(), dummy_header3.filetype());

      result = idx2.read_request(1, 1, 1, -1);
      hdr = blob.read_header<TileHeader>(result.blob_offset());
      retrieved_data = blob.read_data(result.blob_offset());
      check_data(m_test_data, retrieved_data);
      TS_ASSERT_EQUALS(hdr.col(), dummy_header4.col());
      TS_ASSERT_EQUALS(hdr.row(), dummy_header4.row());
      TS_ASSERT_EQUALS(hdr.level(), dummy_header4.level());
      TS_ASSERT_EQUALS(hdr.filetype(), dummy_header4.filetype());
    }
  }

  void test_valid_tiles() {
    const std::string plate_filename = "/tmp/foo.plate";
    std::string blob_filename = plate_filename + "/plate_0.blob";
    fs::remove_all(plate_filename);

    TileHeader dummy_header0;
    dummy_header0.set_filetype("tif");
    dummy_header0.set_col(0);
    dummy_header0.set_row(0);
    dummy_header0.set_level(0);
    dummy_header0.set_transaction_id(100);

    TileHeader dummy_header1;
    dummy_header1.set_filetype("tif");
    dummy_header1.set_col(0);
    dummy_header1.set_row(0);
    dummy_header1.set_level(1);
    dummy_header1.set_transaction_id(100);

    TileHeader dummy_header2;
    dummy_header2.set_filetype("tif");
    dummy_header2.set_col(1);
    dummy_header2.set_row(0);
    dummy_header2.set_level(1);
    dummy_header2.set_transaction_id(100);

    TileHeader dummy_header3;
    dummy_header3.set_filetype("tif");
    dummy_header3.set_col(0);
    dummy_header3.set_row(1);
    dummy_header3.set_level(1);
    dummy_header3.set_transaction_id(100);

    TileHeader dummy_header4;
    dummy_header4.set_filetype("tif");
    dummy_header4.set_col(1);
    dummy_header4.set_row(1);
    dummy_header4.set_level(1);
    dummy_header4.set_transaction_id(100);

    // Write some data to the Index.
    IndexHeader hdr;
    hdr.set_tile_size(256);
    hdr.set_tile_filetype("tif");
    hdr.set_pixel_format(VW_PIXEL_RGB);
    hdr.set_channel_type(VW_CHANNEL_UINT8);
    LocalIndex idx(plate_filename, hdr);
    Blob blob(blob_filename);

    IndexRecord rec;
    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header0, m_test_data, 20));
    idx.write_update(dummy_header0, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header1, m_test_data, 20));
    idx.write_update(dummy_header1, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header2, m_test_data, 20));
    idx.write_update(dummy_header2, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header3, m_test_data, 20));
    idx.write_update(dummy_header3, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header4, m_test_data, 20));
    idx.write_update(dummy_header4, rec);
    idx.write_complete(rec.blob_id(), vw::uint64());
    
    // Test valid_tiles() call at level 0;
    std::list<TileHeader> tiles = idx.valid_tiles(0, BBox2i(0,0,1,1), 100, 100, 0);
    TS_ASSERT_EQUALS(tiles.size(), 1);

    tiles = idx.valid_tiles(1, BBox2i(0,0,2,2), 100, 100, 0);
    TS_ASSERT_EQUALS(tiles.size(), 4);
  }

}; // class TestIndexPage
