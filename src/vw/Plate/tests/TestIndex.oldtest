// __BEGIN_LICENSE__
// Copyright (C) 2006-2009 United States Government as represented by
// the Administrator of the National Aeronautics and Space Administration.
// All Rights Reserved.
// __END_LICENSE__


#include <cxxtest/TestSuite.h>

#include <vw/Plate/LocalIndex.h>

using namespace std;
using namespace vw;
using namespace vw::platefile;

class TestIndexNode : public CxxTest::TestSuite {
  boost::shared_array<uint8> m_test_data;


public:

  TestIndexNode() {
    m_test_data = boost::shared_array<uint8>(new uint8[20]);
    for (int i = 0; i < 20; ++i) {
      m_test_data[i] = i;
    }
  }
  
  void check_data(boost::shared_array<uint8> a, boost::shared_array<uint8> b) {
    for (int i = 0; i < 20; ++i) 
      TS_ASSERT_EQUALS( a[i], b[i] );
  }


  void test_index_record() {

    // Test serialization/deserialization
    TileHeader write_hdr;
    write_hdr.set_filetype("tiff");
    write_hdr.set_col(1);
    write_hdr.set_row(1);
    write_hdr.set_depth(2);
    
    std::ofstream ostr("/tmp/foo.bar", std::ios::binary);
    write_hdr.SerializeToOstream(&ostr);
    ostr.close();

    std::ifstream istr("/tmp/foo.bar", std::ios::binary);
    TileHeader read_hdr;
    read_hdr.ParseFromIstream(&istr);
    istr.close();

    TS_ASSERT_EQUALS(write_hdr.col(), read_hdr.col());
    TS_ASSERT_EQUALS(write_hdr.row(), read_hdr.row());
    TS_ASSERT_EQUALS(write_hdr.depth(), read_hdr.depth());
    TS_ASSERT_EQUALS(write_hdr.filetype(), read_hdr.filetype());

    // Clean up
    unlink("/tmp/foo.bar");
  }

  void test_index_write_read() {
    unlink("/tmp/foo.plate/plate.index");
    std::string plate_filename = "/tmp/foo.plate";

    // Write the basic data...
    IndexHeader rec;
    rec.set_tile_size(256);
    rec.set_tile_filetype("tif");
    rec.set_pixel_format(VW_PIXEL_RGB);
    rec.set_channel_type(VW_CHANNEL_UINT8);
    LocalIndex idx(plate_filename, rec);

    // And read it back in...
    LocalIndex idx2(plate_filename);
    
    TS_ASSERT_EQUALS(idx.version(), idx2.version());
    TS_ASSERT_EQUALS(idx.tile_size(), idx2.tile_size());
    TS_ASSERT_EQUALS(idx.tile_filetype(), idx2.tile_filetype());
  }

  void test_index_transactions() {
    unlink("/tmp/foo.plate/plate.index");
    std::string plate_filename = "/tmp/foo.plate";

    // Write the basic data...
    IndexHeader rec;
    rec.set_tile_size(256);
    rec.set_tile_filetype("tif");
    rec.set_pixel_format(VW_PIXEL_RGB);
    rec.set_channel_type(VW_CHANNEL_UINT8);
    LocalIndex idx(plate_filename, rec);

    TS_ASSERT_EQUALS(idx.transaction_cursor(), 0);

    // Test one tranaction request
    std::vector<TileHeader> empty_tileheader_list; 
    int tx1 = idx.transaction_request("Test transaction #1", empty_tileheader_list);
    TS_ASSERT_EQUALS(tx1, 1);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 0);

    // And now a few more
    int tx2 = idx.transaction_request("Test transaction #2", empty_tileheader_list);
    int tx3 = idx.transaction_request("Test transaction #3", empty_tileheader_list);
    int tx4 = idx.transaction_request("Test transaction #4", empty_tileheader_list);
    int tx5 = idx.transaction_request("Test transaction #5", empty_tileheader_list);
    int tx6 = idx.transaction_request("Test transaction #6", empty_tileheader_list);
    TS_ASSERT_EQUALS(tx2, 2);
    TS_ASSERT_EQUALS(tx3, 3);
    TS_ASSERT_EQUALS(tx4, 4);
    TS_ASSERT_EQUALS(tx5, 5);
    TS_ASSERT_EQUALS(tx6, 6);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 0);

    // Now complet a transaction, but not the next one in the series.
    idx.transaction_complete(tx6);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 0);

    // Now we complete the next one. the cursor should move forward by one.
    idx.transaction_complete(tx1);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 1);

    // Complete more transactions in reverse order
    idx.transaction_complete(tx3);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 1);
    idx.transaction_complete(tx2);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 3);

    // And the rest
    idx.transaction_complete(tx4);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 4);
    idx.transaction_complete(tx5);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 6);
  }


  void test_index_transactions_with_mipmap() {
    unlink("/tmp/foo.plate/plate.index");
    std::string plate_filename = "/tmp/foo.plate";

    // Write the basic data...
    IndexHeader rec;
    rec.set_tile_size(256);
    rec.set_tile_filetype("tif");
    rec.set_pixel_format(VW_PIXEL_RGB);
    rec.set_channel_type(VW_CHANNEL_UINT8);
    LocalIndex idx(plate_filename, rec);

    TS_ASSERT_EQUALS(idx.transaction_cursor(), 0);

    // Test a tranaction request that has one root tile passed to it.
    // This should cause IndexRecords to be created for this
    // transaction ID at higher levels of the quad tree, but these
    // entries will be invalid (in a real platefile, they will get
    // filled in by the mipmapper).
    std::vector<TileHeader> tileheader_list; 
    TileHeader hdr;
    hdr.set_col(0);
    hdr.set_row(0);
    hdr.set_depth(1);
    tileheader_list.push_back(hdr);
    int tx1 = idx.transaction_request("Test transaction #1", tileheader_list);
    TS_ASSERT_EQUALS(tx1, 1);
    TS_ASSERT_EQUALS(idx.transaction_cursor(), 0);

    // Check to make sure that the 0,0,0 tile has an invalid
    // IndexRecord.  Invalid IndexRecords have a blob_id of -1.
    IndexRecord rec2 = idx.read_request(0, 0, 0, tx1);
    TS_ASSERT_EQUALS(rec2.blob_id(), -1);
    TS_ASSERT_EQUALS(rec2.blob_offset(), 0);
  }



  void test_simple_index() {
    std::string plate_filename = "/tmp/foo.plate";
    std::string index_filename = plate_filename + "/plate.index";
    std::string blob_filename = plate_filename + "/plate_0.blob";
    
    unlink(index_filename.c_str());
    unlink(blob_filename.c_str());

    TileHeader dummy_header0;
    dummy_header0.set_filetype("tif");
    dummy_header0.set_col(0);
    dummy_header0.set_row(0);
    dummy_header0.set_depth(0);

    TileHeader dummy_header1;
    dummy_header1.set_filetype("tif");
    dummy_header1.set_col(0);
    dummy_header1.set_row(0);
    dummy_header1.set_depth(1);

    TileHeader dummy_header2;
    dummy_header2.set_filetype("tif");
    dummy_header2.set_col(1);
    dummy_header2.set_row(0);
    dummy_header2.set_depth(1);

    TileHeader dummy_header3;
    dummy_header3.set_filetype("tif");
    dummy_header3.set_col(0);
    dummy_header3.set_row(1);
    dummy_header3.set_depth(1);

    TileHeader dummy_header4;
    dummy_header4.set_filetype("tif");
    dummy_header4.set_col(1);
    dummy_header4.set_row(1);
    dummy_header4.set_depth(1);

    // Write some data to the Index.
    IndexHeader hdr;
    hdr.set_tile_size(256);
    hdr.set_tile_filetype("tif");
    hdr.set_pixel_format(VW_PIXEL_RGB);
    hdr.set_channel_type(VW_CHANNEL_UINT8);
    LocalIndex idx(plate_filename, hdr);
    Blob blob(blob_filename);

    IndexRecord rec;
    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header0, m_test_data, 20));
    idx.write_complete(dummy_header0, rec);

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header1, m_test_data, 20));
    idx.write_complete(dummy_header1, rec);

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header2, m_test_data, 20));
    idx.write_complete(dummy_header2, rec);

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header3, m_test_data, 20));
    idx.write_complete(dummy_header3, rec);

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header4, m_test_data, 20));
    idx.write_complete(dummy_header4, rec);

    // Test re-writing (i.e. changing) an entry.
    TileHeader dummy_header5;
    dummy_header5.set_filetype("tif");
    dummy_header5.set_col(1);
    dummy_header5.set_row(1);
    dummy_header5.set_depth(1);

    rec.set_blob_id( idx.write_request(1024) );
    rec.set_blob_offset(blob.write(dummy_header1, m_test_data, 20));
    idx.write_complete(dummy_header1, rec);

    IndexRecord result = idx.read_request(0, 0, 1, -1);
    TS_ASSERT_EQUALS(result.blob_id(), rec.blob_id());
    TS_ASSERT_EQUALS(result.blob_offset(), rec.blob_offset());

    // Now let's try some invalid reads/writes
    dummy_header5.set_col(10);
    TS_ASSERT_THROWS(idx.write_complete(dummy_header5, rec), TileNotFoundErr);
    dummy_header5.set_col(0);
    dummy_header5.set_row(2);
    dummy_header5.set_depth(1);
    TS_ASSERT_THROWS(idx.write_complete(dummy_header5, rec), TileNotFoundErr);

    TS_ASSERT_THROWS(idx.read_request(0, 0, 2, -1), TileNotFoundErr);
  }

  void test_index_read_write() {
    std::string plate_filename = "/tmp/foo.plate";
    std::string index_filename = plate_filename + "/plate.index";
    std::string blob_filename = plate_filename + "/plate_0.blob";
    
    unlink(index_filename.c_str());
    unlink(blob_filename.c_str());

    TileHeader dummy_header0;
    dummy_header0.set_filetype("tif");
    dummy_header0.set_col(0);
    dummy_header0.set_row(0);
    dummy_header0.set_depth(0);

    TileHeader dummy_header1;
    dummy_header1.set_filetype("tif");
    dummy_header1.set_col(0);
    dummy_header1.set_row(0);
    dummy_header1.set_depth(1);

    TileHeader dummy_header2;
    dummy_header2.set_filetype("tif");
    dummy_header2.set_col(1);
    dummy_header2.set_row(0);
    dummy_header2.set_depth(1);

    TileHeader dummy_header3;
    dummy_header3.set_filetype("tif");
    dummy_header3.set_col(0);
    dummy_header3.set_row(1);
    dummy_header3.set_depth(1);

    TileHeader dummy_header4;
    dummy_header4.set_filetype("tif");
    dummy_header4.set_col(1);
    dummy_header4.set_row(1);
    dummy_header4.set_depth(1);

    // Write some data to the Index. 
    { 
      IndexHeader hdr;
      hdr.set_tile_size(256);
      hdr.set_tile_filetype("tif");
      hdr.set_pixel_format(VW_PIXEL_RGB);
      hdr.set_channel_type(VW_CHANNEL_UINT8);
      LocalIndex idx(plate_filename, hdr);
      Blob blob(blob_filename);

      IndexRecord rec;
      rec.set_blob_id( idx.write_request(1024) );
      rec.set_blob_offset(blob.write(dummy_header0, m_test_data, 20));
      idx.write_complete(dummy_header0, rec);

      rec.set_blob_id( idx.write_request(1024) );
      rec.set_blob_offset(blob.write(dummy_header1, m_test_data, 20));
      idx.write_complete(dummy_header1, rec);
      
      rec.set_blob_id( idx.write_request(1024) );
      rec.set_blob_offset(blob.write(dummy_header2, m_test_data, 20));
      idx.write_complete(dummy_header2, rec);
      
      rec.set_blob_id( idx.write_request(1024) );
      rec.set_blob_offset(blob.write(dummy_header3, m_test_data, 20));
      idx.write_complete(dummy_header3, rec);
      
      rec.set_blob_id( idx.write_request(1024) );
      rec.set_blob_offset(blob.write(dummy_header4, m_test_data, 20));
      idx.write_complete(dummy_header4, rec);
    }

    // Now, let's save the data to disk, and then read it back.
    {
      LocalIndex idx2(plate_filename);
      Blob blob(blob_filename);

      // Read the data back from the index
      IndexRecord result = idx2.read_request(0, 0, 0, -1);
      TileHeader hdr = blob.read_header<TileHeader>(result.blob_offset());
      boost::shared_array<uint8> retrieved_data = blob.read_data(result.blob_offset());
      check_data(m_test_data, retrieved_data);
      TS_ASSERT_EQUALS(hdr.col(), dummy_header0.col());
      TS_ASSERT_EQUALS(hdr.row(), dummy_header0.row());
      TS_ASSERT_EQUALS(hdr.depth(), dummy_header0.depth());
      TS_ASSERT_EQUALS(hdr.filetype(), dummy_header0.filetype());

      result = idx2.read_request(0, 0, 1, -1);
      hdr = blob.read_header<TileHeader>(result.blob_offset());
      retrieved_data = blob.read_data(result.blob_offset());
      check_data(m_test_data, retrieved_data);
      TS_ASSERT_EQUALS(hdr.col(), dummy_header1.col());
      TS_ASSERT_EQUALS(hdr.row(), dummy_header1.row());
      TS_ASSERT_EQUALS(hdr.depth(), dummy_header1.depth());
      TS_ASSERT_EQUALS(hdr.filetype(), dummy_header1.filetype());

      result = idx2.read_request(1, 0, 1, -1);
      hdr = blob.read_header<TileHeader>(result.blob_offset());
      retrieved_data = blob.read_data(result.blob_offset());
      check_data(m_test_data, retrieved_data);
      TS_ASSERT_EQUALS(hdr.col(), dummy_header2.col());
      TS_ASSERT_EQUALS(hdr.row(), dummy_header2.row());
      TS_ASSERT_EQUALS(hdr.depth(), dummy_header2.depth());
      TS_ASSERT_EQUALS(hdr.filetype(), dummy_header2.filetype());

      result = idx2.read_request(0, 1, 1, -1);
      hdr = blob.read_header<TileHeader>(result.blob_offset());
      retrieved_data = blob.read_data(result.blob_offset());
      check_data(m_test_data, retrieved_data);
      TS_ASSERT_EQUALS(hdr.col(), dummy_header3.col());
      TS_ASSERT_EQUALS(hdr.row(), dummy_header3.row());
      TS_ASSERT_EQUALS(hdr.depth(), dummy_header3.depth());
      TS_ASSERT_EQUALS(hdr.filetype(), dummy_header3.filetype());

      result = idx2.read_request(1, 1, 1, -1);
      hdr = blob.read_header<TileHeader>(result.blob_offset());
      retrieved_data = blob.read_data(result.blob_offset());
      check_data(m_test_data, retrieved_data);
      TS_ASSERT_EQUALS(hdr.col(), dummy_header4.col());
      TS_ASSERT_EQUALS(hdr.row(), dummy_header4.row());
      TS_ASSERT_EQUALS(hdr.depth(), dummy_header4.depth());
      TS_ASSERT_EQUALS(hdr.filetype(), dummy_header4.filetype());
    }

    unlink(index_filename.c_str());
    unlink(blob_filename.c_str());
  }

}; // class TestIndex
