// __BEGIN_LICENSE__
// Copyright (C) 2006-2009 United States Government as represented by
// the Administrator of the National Aeronautics and Space Administration.
// All Rights Reserved.
// __END_LICENSE__


#include <cxxtest/TestSuite.h>
#include <boost/smart_ptr.hpp>

#include <vw/Plate/Tree.h>

using namespace std;
using namespace vw::platefile;

class TestTreeNode : public CxxTest::TestSuite {

public:
  typedef TreeNode<int> tree_type;

  void test_simple_tree_manipulation() {
    boost::shared_ptr<tree_type> root( new tree_type(0, 0) );
    TS_ASSERT_EQUALS(root->value(0), 0);

    // Insert some level 1 children
    root->insert(10, 0, 0, 1, 0);
    root->insert(11, 1, 0, 1, 0);
    root->insert(12, 0, 1, 1, 0);
    root->insert(13, 1, 1, 1, 0);

    TS_ASSERT_EQUALS(root->child(0)->value(0), 10);
    TS_ASSERT_EQUALS(root->child(1)->value(0), 11);
    TS_ASSERT_EQUALS(root->child(2)->value(0), 12);
    TS_ASSERT_EQUALS(root->child(3)->value(0), 13);

    // Insert one level 2 child
    root->insert(20, 3, 3, 2, 0);
    root->insert(30, 3, 3, 3, 0);
    TS_ASSERT_EQUALS(root->child(3)->child(3)->value(0), 20);

    // Try overwriting some values
    root->insert(101, 0, 0, 1, 0);
    TS_ASSERT_EQUALS(root->child(0)->value(0), 101);

    // Test an invalid index
    TS_ASSERT_THROWS(root->insert(10,2,1,1,0), TileNotFoundErr); // IndexErr
    TS_ASSERT_THROWS(root->insert(1,0,1,0,0), TileNotFoundErr);  // IndexErr
  }

  void test_search() {

    boost::shared_ptr<tree_type> root( new tree_type(0, 0) );
    TS_ASSERT_EQUALS(root->value(0), 0);

    // Insert some level 1 children
    root->insert(10, 0, 0, 1, 0);
    root->insert(11, 1, 0, 1, 0);
    root->insert(12, 0, 1, 1, 0);
    root->insert(13, 1, 1, 1, 0);

    // Insert one level 2 child and one level 3 child
    root->insert(20, 3, 3, 2, 0);
    root->insert(30, 3, 3, 3, 0);

    // Now search for the nodes in level 3
    int result = root->search(3,3,2,0);
    TS_ASSERT_EQUALS(result, 20);

    // Check level 2
    result = root->search(3,3,3,0);
    TS_ASSERT_EQUALS(result, 30);

    // Check level 1
    result = root->search(0,0,1,0);
    TS_ASSERT_EQUALS(result, 10);
    result = root->search(1,0,1,0);
    TS_ASSERT_EQUALS(result, 11);
    result = root->search(0,1,1,0);
    TS_ASSERT_EQUALS(result, 12);
    result = root->search(1,1,1,0);
    TS_ASSERT_EQUALS(result, 13);
    
    // Check level 0
    result = root->search(0,0,1,0);

    // Test searches on nodes that should be invalid
    TS_ASSERT_THROWS(root->search(3,4,3,0), TileNotFoundErr);
    TS_ASSERT_THROWS(root->search(3,8,3,0), TileNotFoundErr); // IndexErr
    TS_ASSERT_THROWS(root->search(3,4,5,0), TileNotFoundErr);
    TS_ASSERT_THROWS(root->search(0,0,2,0), TileNotFoundErr);
  }

  void test_basic_transaction_id() {
    boost::shared_ptr<tree_type> root( new tree_type(0, 0) );
    TS_ASSERT_EQUALS(root->value(0), 0);

    // Insert some level 1 children with transaction ID 0.
    root->insert(10, 0, 0, 1, 0);
    root->insert(11, 1, 0, 1, 0);
    root->insert(12, 0, 1, 1, 0);
    root->insert(13, 1, 1, 1, 0);

    // Now "replace" two of the tiles with transaction ID 1
    root->insert(21, 1, 0, 1, 1);
    root->insert(23, 1, 1, 1, 1);


    // Now search for tiles
    int result = root->search(0,0,1,0);
    TS_ASSERT_EQUALS(result, 10);
    result = root->search(1,0,1,0);
    TS_ASSERT_EQUALS(result, 11);
    result = root->search(0,1,1,0);
    TS_ASSERT_EQUALS(result, 12);
    result = root->search(1,1,1,0);
    TS_ASSERT_EQUALS(result, 13);
    
    // Transaction ID = 1 tiles
    result = root->search(1,0,1,1);
    TS_ASSERT_EQUALS(result, 21);
    result = root->search(1,1,1,1);
    TS_ASSERT_EQUALS(result, 23);

    // Accessing the "latest" transaction ID, whatever that is.
    result = root->search(0,0,1,-1);
    TS_ASSERT_EQUALS(result, 10);
    result = root->search(1,0,1,-1);
    TS_ASSERT_EQUALS(result, 21);
    result = root->search(0,1,1,-1);
    TS_ASSERT_EQUALS(result, 12);
    result = root->search(1,1,1,-1);
    TS_ASSERT_EQUALS(result, 23);
    

    // Writing to an existing transaction ID should cause the data to
    // be overwritten
    root->insert(31, 1, 0, 1, 1);
    result = root->search(1,0,1,1);
    TS_ASSERT_EQUALS(result, 31);
    result = root->search(1,0,1,-1);
    TS_ASSERT_EQUALS(result, 31);
    result = root->search(1,0,1,0);
    TS_ASSERT_EQUALS(result, 11);

    // Skipping an entry should be no problem
    root->insert(41, 1, 0, 1, 3);
    result = root->search(1,0,1,3);
    TS_ASSERT_EQUALS(result, 41);
    result = root->search(1,0,1,-1);
    TS_ASSERT_EQUALS(result, 41);
    result = root->search(1,0,1,0);
    TS_ASSERT_EQUALS(result, 11);
    result = root->search(1,0,1,1);
    TS_ASSERT_EQUALS(result, 31);

    // And inserting an entry in between should still work, but not
    // move the final transaction id forward any.
    root->insert(51, 1, 0, 1, 2);
    result = root->search(1,0,1,3);
    TS_ASSERT_EQUALS(result, 41);
    result = root->search(1,0,1,2);
    TS_ASSERT_EQUALS(result, 51);
    result = root->search(1,0,1,1);
    TS_ASSERT_EQUALS(result, 31);
    result = root->search(1,0,1,0);
    TS_ASSERT_EQUALS(result, 11);
    result = root->search(1,0,1,-1);
    TS_ASSERT_EQUALS(result, 41);
  }


  void test_missing_transaction_id() {
    boost::shared_ptr<tree_type> root( new tree_type(0,0) );
    TS_ASSERT_EQUALS(root->value(0), 0);

    // Insert some level 1 children with transaction ID 0.
    root->insert(10, 0, 0, 1, 1);
    root->insert(11, 1, 0, 1, 1);
    root->insert(12, 0, 1, 1, 1);
    root->insert(13, 1, 1, 1, 1);

    // Now "replace" two of the tiles with transaction ID 1
    root->insert(21, 1, 0, 1, 3);
    root->insert(23, 1, 1, 1, 3);

    // Make sure that a non-existent tile throws a TileNotFoundErr
    TS_ASSERT_THROWS(root->search(1,0,1,0), TileNotFoundErr);

    int result = root->search(1,0,1,-1);
    TS_ASSERT_EQUALS(result, 21);
    result = root->search(1,0,1,1);
    TS_ASSERT_EQUALS(result, 11);
    result = root->search(1,0,1,2);
    TS_ASSERT_EQUALS(result, 11);
  }

  void test_intermediate_default_transaction_ids() {
    boost::shared_ptr<tree_type> root( new tree_type(0,0) );
    TS_ASSERT_EQUALS(root->value(0), 0);

    // Insert some level 1 children with transaction ID 0.
    root->insert(10, 0, 0, 2, 1);

    TS_ASSERT_THROWS(root->search(0,0,1,0), TileNotFoundErr);
    TS_ASSERT_THROWS(root->search(0,0,2,0), TileNotFoundErr);

    int result = root->search(0,0,1,1);
    TS_ASSERT_EQUALS(result, 0);
    result = root->search(0,0,2,1);
    TS_ASSERT_EQUALS(result, 10);
  }


}; // class TestTree
